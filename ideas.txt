-see if you can make the algorithm use a weighted average of the sobelxs (resp. sobelys, sobels) at the four integer coordinates nearest a floating-point coordinate pair instead of just the nearest lattice point

-write up a summary of what we accomplished today (pixel_path) ✔?

-we chose to use d(theta)/ds to represent curvature, but there are many other formulas on the wikipedia page.
write about what curvature is; how can we use our list of points generated by pixel_path() to obtain the curvature of the edge at each point?

-recursive version of pixel_path ✔

* * * * *

-algorithm for determining the background color(s) of the image using the boundary of the image, also telling how monochrome the background seems to be. Incl. boundary_color_statistics.

-using lambda expressions to make functions of functions, in order to lift the three sobel matrices defined at integers to weighted sums for pairs of floats.

-pixel_path takes about .1s for a normal piece from "dave".

-checking pixels for whether they're above a cutoff range takes 1μs.
So checking a large picture like "dave" takes 2s;
checking a huge picture takes 80s.

-keep a matrix of boolean values according as a pixel has been checked or not. When pixel_path is run, add a 1 or 2 pixel boundary (include as an argument) of Trues, and fill in the interior with Trues.

-borrow or buy jigsaw puzzles of different sizes, put them on a monochrome table and take pictures.
